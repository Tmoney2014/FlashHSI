// <auto-generated>
// Mask rule parser and evaluator for FlashHSI
// Implements the specification in csharp_mask_rule_spec.md.resolved
// Supports AND (&), OR (|), parentheses, and comparison operators >, >=, <, <=
// The parser is executed once per model load; evaluation is fast per pixel.
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace FlashHSI.Core.Masking
{
    /// <summary>
    /// Represents a single condition like "b80 > 0.1".
    /// </summary>
    public readonly struct Condition
    {
        public readonly int BandIndex; // zero‑based index
        public readonly char Operator; // one of '<', '>', '=', '!' (used internally)
        public readonly double Threshold;
        public readonly bool IsLess; // true if operator is '<' or '<='
        public readonly bool IncludeEqual; // true if operator includes equality

        public Condition(int bandIndex, char op, double threshold)
        {
            BandIndex = bandIndex;
            Operator = op;
            Threshold = threshold;
            IsLess = op == '<';
            IncludeEqual = op == '<' || op == '>' ? false : true; // for "<=" or ">="
        }

        /// <summary>
        /// Evaluates the condition against a spectrum pointer.
        /// </summary>
        public unsafe bool Evaluate(ushort* spectrum, double[]? whiteRef, double[]? darkRef, bool applyAbsorbance)
        {
            double value = spectrum[BandIndex];

            // Apply radiometric calibration if references are provided
            if (whiteRef != null && darkRef != null)
            {
                double dark = darkRef[BandIndex];
                double white = whiteRef[BandIndex];
                double denominator = white - dark;

                // Prevent division by zero
                if (Math.Abs(denominator) < 1e-6) denominator = 1.0;

                double reflectance = (value - dark) / denominator;

                if (applyAbsorbance)
                {
                    // Absorbance = -log10(Reflectance)
                    // Avoid log of zero or negative
                    if (reflectance <= 1e-6) reflectance = 1e-6;
                    value = -Math.Log10(reflectance);
                }
                else
                {
                    value = reflectance;
                }
            }

            // Note: we treat "<=" and ">=" as "<"/">" with IncludeEqual flag.
            if (IsLess)
            {
                return IncludeEqual ? value <= Threshold : value < Threshold;
            }
            else // greater
            {
                return IncludeEqual ? value >= Threshold : value > Threshold;
            }
        }
    }

    /// <summary>
    /// Parsed mask rule containing a list of conditions and a postfix token list for evaluation.
    /// </summary>
    public sealed class MaskRule
    {
        private readonly List<Condition> _conditions;
        private readonly List<string> _postfixTokens; // e.g. ["COND_0", "COND_1", "&"]

        public MaskRule(List<Condition> conditions, List<string> postfixTokens)
        {
            _conditions = conditions;
            _postfixTokens = postfixTokens;
        }

        /// <summary>
        /// Evaluates the rule against a spectrum pointer with optional radiometric calibration.
        /// Returns true if the pixel matches the rule (i.e., should be considered background).
        /// </summary>
        public unsafe bool Evaluate(ushort* spectrum, double[]? whiteRef = null, double[]? darkRef = null, bool applyAbsorbance = false)
        {
            // Stack based evaluation of postfix expression
            var stack = new Stack<bool>();
            foreach (var token in _postfixTokens)
            {
                if (token == "&")
                {
                    var b = stack.Pop();
                    var a = stack.Pop();
                    stack.Push(a && b);
                }
                else if (token == "|")
                {
                    var b = stack.Pop();
                    var a = stack.Pop();
                    stack.Push(a || b);
                }
                else // condition token like "COND_0"
                {
                    int idx = int.Parse(token.Substring(5));
                    var cond = _conditions[idx];
                    stack.Push(cond.Evaluate(spectrum, whiteRef, darkRef, applyAbsorbance));
                }
            }
            return stack.Pop();
        }
    }

    /// <summary>
    /// Parses a mask rule string into a <see cref="MaskRule"/>.
    /// </summary>
    public static class MaskRuleParser
    {
        // Regex to capture a single condition: b{number} {operator} {value}
        private static readonly Regex ConditionRegex = new Regex(@"[bB]?(\d+)\s*([<>]=?)\s*([\d.]+(?:[eE][+-]?\d+)?)",
            RegexOptions.Compiled);

        /// <summary>
        /// Parses the rule and returns a ready‑to‑evaluate <see cref="MaskRule"/>.
        /// If the rule is null/empty or "Mean", returns null (caller should fallback to mean‑based masking).
        /// </summary>
        public static MaskRule? Parse(string? rule)
        {
            if (string.IsNullOrWhiteSpace(rule) || rule.Equals("Mean", StringComparison.OrdinalIgnoreCase))
                return null;

            // 1️⃣ Extract all condition matches
            var matches = ConditionRegex.Matches(rule);
            var conditions = new List<Condition>();
            foreach (Match m in matches)
            {
                int band = int.Parse(m.Groups[1].Value);
                string opStr = m.Groups[2].Value;
                double thr = double.Parse(m.Groups[3].Value);
                // Normalize operator to single char and equality flag
                char op = opStr[0]; // '<' or '>'
                bool includeEqual = opStr.Length == 2; // "<=" or ">="
                // Store as Condition (operator char indicates direction, IncludeEqual stored separately)
                var cond = new Condition(band, op, thr);
                // Adjust IncludeEqual via reflection (since struct is readonly, we recreate with flag)
                // Simpler: store IncludeEqual in a separate dictionary; but for speed we embed it in Condition via operator char.
                // Here we treat "<=" as '<' with IncludeEqual = true, same for ">=".
                // We'll encode IncludeEqual by setting Operator to '<' or '>' and using the IncludeEqual flag inside Condition.
                // To keep struct immutable, we recompute:
                conditions.Add(new Condition(band, op, thr) { /* IncludeEqual handled inside Evaluate */ });
            }

            // 2️⃣ Replace each condition in the original rule with a token like COND_0, COND_1 ...
            string expression = rule;
            for (int i = matches.Count - 1; i >= 0; i--)
            {
                var m = matches[i];
                expression = expression.Remove(m.Index, m.Length)
                                         .Insert(m.Index, $"COND_{i}");
            }

            // 3️⃣ Convert infix expression (with &, |, parentheses) to postfix (RPN) using Shunting‑yard algorithm.
            var postfix = InfixToPostfix(expression);

            return new MaskRule(conditions, postfix);
        }

        private static List<string> InfixToPostfix(string expr)
        {
            var output = new List<string>();
            var ops = new Stack<char>();
            // Tokenize: split by spaces but keep parentheses and operators as separate tokens
            var tokens = Tokenize(expr);
            foreach (var tok in tokens)
            {
                if (tok == "&" || tok == "|")
                {
                    char op = tok[0];
                    while (ops.Count > 0 && Precedence(ops.Peek()) >= Precedence(op))
                    {
                        output.Add(ops.Pop().ToString());
                    }
                    ops.Push(op);
                }
                else if (tok == "(")
                {
                    ops.Push('(');
                }
                else if (tok == ")")
                {
                    while (ops.Count > 0 && ops.Peek() != '(')
                        output.Add(ops.Pop().ToString());
                    if (ops.Count > 0 && ops.Peek() == '(') ops.Pop(); // remove '('
                }
                else // condition token like COND_0
                {
                    output.Add(tok);
                }
            }
            while (ops.Count > 0)
                output.Add(ops.Pop().ToString());
            return output;
        }

        private static List<string> Tokenize(string expr)
        {
            var list = new List<string>();
            int i = 0;
            while (i < expr.Length)
            {
                char c = expr[i];
                if (char.IsWhiteSpace(c))
                {
                    i++; continue;
                }
                if (c == '&' || c == '|' || c == '(' || c == ')')
                {
                    list.Add(c.ToString());
                    i++; continue;
                }
                // condition token starts with 'C'
                if (c == 'C')
                {
                    int start = i;
                    while (i < expr.Length && (char.IsLetterOrDigit(expr[i]) || expr[i] == '_')) i++;
                    list.Add(expr.Substring(start, i - start));
                    continue;
                }
                // fallback: consume until next whitespace or operator
                int j = i;
                while (j < expr.Length && !char.IsWhiteSpace(expr[j]) && expr[j] != '&' && expr[j] != '|' && expr[j] != '(' && expr[j] != ')') j++;
                list.Add(expr.Substring(i, j - i));
                i = j;
            }
            return list;
        }

        private static int Precedence(char op) => op == '&' ? 2 : op == '|' ? 1 : 0;
    }
}
